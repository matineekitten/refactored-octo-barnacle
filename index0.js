class Task {   constructor(id, fn, priority = 1, retries = 3) {     this.id = id;     this.fn = fn;     this.priority = priority;     this.retries = retries;     this.status = 'pending';   }    async execute() {     let attempts = 0;     this.status = 'running';     while (attempts < this.retries) {       try {         const result = await this.fn();         this.status = 'completed';         return result;       } catch (e) {         attempts++;         console.warn(`Task  failed attempt . Retrying...`);         if (attempts >= this.retries) {           this.status = 'failed';           throw new Error(`Task  failed after  retries.`);         }         await this.delay(500);       }     }   }    delay(ms) {     return new Promise(resolve => setTimeout(resolve, ms));   } }  class Scheduler {   constructor(concurrency = 3) {     this.queue = [];     this.activeTasks = new Map();     this.concurrency = concurrency;     this.running = false;   }    addTask(task) {     this.queue.push(task);     this.queue.sort((a, b) => b.priority - a.priority);   }    async start() {     if (this.running) return;     this.running = true;     while (this.running && (this.queue.length > 0 || this.activeTasks.size > 0)) {       while (this.activeTasks.size < this.concurrency && this.queue.length > 0) {         const task = this.queue.shift();         this.runTask(task);       }       await this.sleep(100);     }     this.running = false;   }    async runTask(task) {     this.activeTasks.set(task.id, task);     try {       const result = await task.execute();       console.log(`Task  completed with result:`, result);     } catch (e) {       console.error(`Task  error:`, e.message);     } finally {       this.activeTasks.delete(task.id);     }   }    sleep(ms) {     return new Promise(resolve => setTimeout(resolve, ms));   }    stop() {     this.running = false;   } }  // Example: create async task functions const createMockTask = (id, successRate = 0.8, delay = 300) => {   return async () => {     await new Promise(res => setTimeout(res, delay));     if (Math.random() > successRate) {       throw new Error(`Task  simulated failure`);     }     return `Result of `;   }; };  // Create tasks with different priorities and retry strategies const tasks = [   new Task('A', createMockTask('A', 0.5), 5, 5),   new Task('B', createMockTask('B'), 1, 3),   new Task('C', createMockTask('C', 0.9), 3, 2),   new Task('D', createMockTask('D'), 2, 4),   new Task('E', createMockTask('E', 0.7), 4, 1),   new Task('F', createMockTask('F'), 1, 2),   new Task('G', createMockTask('G'), 2, 3),   new Task('H', createMockTask('H', 0.85), 3, 2),   new Task('I', createMockTask('I'), 2, 3),   new Task('J', createMockTask('J', 0.6), 5, 5), ];  // Initialize scheduler and add tasks const scheduler = new Scheduler(3); tasks.forEach(task => scheduler.addTask(task)); scheduler.start();
